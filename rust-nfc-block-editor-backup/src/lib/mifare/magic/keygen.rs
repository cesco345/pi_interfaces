use std::error::Error;

const MAGIC_TABLE_SIZE: usize = 192;
const KEY_LENGTH: usize = 6;
const UID_LENGTH: usize = 4;

/// Magic Card key generation constants
const MAGIC_TABLE: [u8; MAGIC_TABLE_SIZE] = [
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xF0, 0x57, 0xB3, 0x9E, 0xE3, 0xD8,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x96, 0x9D, 0x95, 0x4A, 0xC1, 0x57,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x8F, 0x43, 0x58, 0x0D, 0x2C, 0x9D,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xFF, 0xCC, 0xE0, 0x05, 0x0C, 0x43,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x34, 0x1B, 0x15, 0xA6, 0x90, 0xCC,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x89, 0x58, 0x56, 0x12, 0xE7, 0x1B,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xBB, 0x74, 0xB0, 0x95, 0x36, 0x58,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xFB, 0x97, 0xF8, 0x4B, 0x5B, 0x74,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xC9, 0xD1, 0x88, 0x35, 0x9F, 0x92,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x8F, 0x92, 0xE9, 0x7F, 0x58, 0x97,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x16, 0x6C, 0xA2, 0xB0, 0x9F, 0xD1,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x27, 0xDD, 0x93, 0x10, 0x1C, 0x6C,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xDA, 0x3E, 0x3F, 0xD6, 0x49, 0xDD,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x58, 0xDD, 0xED, 0x07, 0x8E, 0x3E,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x5C, 0xD0, 0x05, 0xCF, 0xD9, 0x07,
    0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x11, 0x8D, 0xD0, 0x01, 0x87, 0xD0
];

/// Generate a possible key for a Magic Card based on its UID
pub fn generate_magic_key(uid: &[u8]) -> Result<[u8; KEY_LENGTH], Box<dyn Error>> {
    // Validate UID length
    if uid.len() < UID_LENGTH {
        return Err("UID must be at least 4 bytes long".into());
    }

    // Calculate magic byte based on UID components
    let magic_byte = (uid[3] >> 4) + (uid[2] >> 4) + (uid[0] & 0x0F);
    
    // Calculate the index in the magic table
    let mut magickal_index = ((magic_byte & 0x0F) * 12 + 11) as usize;
    
    // Initialize the key with the magic byte and UID components
    let mut key = [magic_byte, uid[0], uid[1], uid[2], uid[3], magic_byte];
    
    // Apply the magic transformation algorithm
    let mut carry_sum: u8 = 0;
    for i in (0..KEY_LENGTH).rev() {
        if magickal_index < MAGIC_TABLE_SIZE {
            let keysum: u16 = key[i] as u16 + MAGIC_TABLE[magickal_index] as u16 + carry_sum as u16;
            key[i] = (keysum & 0xFF) as u8;
            carry_sum = (keysum >> 8) as u8;
            
            if magickal_index > 0 {
                magickal_index -= 1;
            } else {
                break;
            }
        } else {
            break;
        }
    }
    
    Ok(key)
}

/// Generate and format a key for display
pub fn format_magic_key(uid: &[u8]) -> Result<String, Box<dyn Error>> {
    let key = generate_magic_key(uid)?;
    let formatted_key = key.iter()
        .map(|byte| format!("{:02X}", byte))
        .collect::<Vec<String>>()
        .join("");
    
    Ok(formatted_key)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_key_generation() {
        // Test with a sample UID
        let uid = [0x12, 0x34, 0x56, 0x78];
        let key_result = generate_magic_key(&uid);
        assert!(key_result.is_ok(), "Key generation should succeed");
        
        // Test formatting
        let formatted = format_magic_key(&uid);
        assert!(formatted.is_ok(), "Key formatting should succeed");
        assert_eq!(formatted.unwrap().len(), 12, "Formatted key should be 12 characters");
    }
}
